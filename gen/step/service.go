// Code generated by goa v3.1.1, DO NOT EDIT.
//
// step service
//
// Command:
// $ goa gen guide.me/design

package step

import (
	"context"

	stepviews "guide.me/gen/step/views"
)

// The Step service makes it possible to view, add, modify or remove Steps of a
// Walkthrough.
type Service interface {
	// List all stored Steps for a given walkthrough
	List(context.Context, *ListPayload) (res *StoredSteps, err error)
	// Add new Steps to walkthrough and return ID.
	Add(context.Context, *Steps) (res string, err error)
	// Remove Steps from storage
	Remove(context.Context, *RemovePayload) (err error)
	// Update Steps with the given IDs.
	Update(context.Context, *StoredSteps) (err error)
}

// ServiceName is the name of the service as defined in the design. This is the
// same value that is set in the endpoint request contexts under the ServiceKey
// key.
const ServiceName = "step"

// MethodNames lists the service method names as defined in the design. These
// are the same values that are set in the endpoint request contexts under the
// MethodKey key.
var MethodNames = [4]string{"list", "add", "remove", "update"}

// ListPayload is the payload type of the step service list method.
type ListPayload struct {
	// ID of Walkthrough to search for steps
	ID string
}

// StoredSteps is the result type of the step service list method.
type StoredSteps struct {
	// ID is the unique id of the Step.
	ID string
	// The id of the Walkthrough those steps belong to.
	WtID string
	// List of steps for a given walkthrough.
	Steps []*Step
}

// Steps is the payload type of the step service add method.
type Steps struct {
	// The id of the Walkthrough those steps belong to.
	WtID *string
	// List of steps for a given walkthrough.
	Steps []*Step
}

// RemovePayload is the payload type of the step service remove method.
type RemovePayload struct {
	// ID of Steps to remove
	ID string
}

// Step describes the basic details of your tutorials.
type Step struct {
	// A string representing the HTML ID of an element
	Targetid string
	// The type of step to be used
	Type string
	// The content of the message to be displayed
	Value string
	// The number in the sequence that the step belongs to.
	Sequence int32
	// What action should trigger the next step
	Action string
}

type ElementNotFound struct {
	// Message of error
	Message string
	// ID of missing element
	ID string
}

// Error returns an error description.
func (e *ElementNotFound) Error() string {
	return ""
}

// ErrorName returns "ElementNotFound".
func (e *ElementNotFound) ErrorName() string {
	return e.Message
}

// NewStoredSteps initializes result type StoredSteps from viewed result type
// StoredSteps.
func NewStoredSteps(vres *stepviews.StoredSteps) *StoredSteps {
	var res *StoredSteps
	switch vres.View {
	case "default", "":
		res = newStoredSteps(vres.Projected)
	case "tiny":
		res = newStoredStepsTiny(vres.Projected)
	}
	return res
}

// NewViewedStoredSteps initializes viewed result type StoredSteps from result
// type StoredSteps using the given view.
func NewViewedStoredSteps(res *StoredSteps, view string) *stepviews.StoredSteps {
	var vres *stepviews.StoredSteps
	switch view {
	case "default", "":
		p := newStoredStepsView(res)
		vres = &stepviews.StoredSteps{Projected: p, View: "default"}
	case "tiny":
		p := newStoredStepsViewTiny(res)
		vres = &stepviews.StoredSteps{Projected: p, View: "tiny"}
	}
	return vres
}

// newStoredSteps converts projected type StoredSteps to service type
// StoredSteps.
func newStoredSteps(vres *stepviews.StoredStepsView) *StoredSteps {
	res := &StoredSteps{}
	if vres.ID != nil {
		res.ID = *vres.ID
	}
	if vres.WtID != nil {
		res.WtID = *vres.WtID
	}
	if vres.Steps != nil {
		res.Steps = make([]*Step, len(vres.Steps))
		for i, val := range vres.Steps {
			res.Steps[i] = transformStepviewsStepViewToStep(val)
		}
	}
	return res
}

// newStoredStepsTiny converts projected type StoredSteps to service type
// StoredSteps.
func newStoredStepsTiny(vres *stepviews.StoredStepsView) *StoredSteps {
	res := &StoredSteps{}
	if vres.ID != nil {
		res.ID = *vres.ID
	}
	if vres.WtID != nil {
		res.WtID = *vres.WtID
	}
	if vres.Steps != nil {
		res.Steps = make([]*Step, len(vres.Steps))
		for i, val := range vres.Steps {
			res.Steps[i] = transformStepviewsStepViewToStep(val)
		}
	}
	return res
}

// newStoredStepsView projects result type StoredSteps to projected type
// StoredStepsView using the "default" view.
func newStoredStepsView(res *StoredSteps) *stepviews.StoredStepsView {
	vres := &stepviews.StoredStepsView{
		ID:   &res.ID,
		WtID: &res.WtID,
	}
	if res.Steps != nil {
		vres.Steps = make([]*stepviews.StepView, len(res.Steps))
		for i, val := range res.Steps {
			vres.Steps[i] = transformStepToStepviewsStepView(val)
		}
	}
	return vres
}

// newStoredStepsViewTiny projects result type StoredSteps to projected type
// StoredStepsView using the "tiny" view.
func newStoredStepsViewTiny(res *StoredSteps) *stepviews.StoredStepsView {
	vres := &stepviews.StoredStepsView{
		ID:   &res.ID,
		WtID: &res.WtID,
	}
	if res.Steps != nil {
		vres.Steps = make([]*stepviews.StepView, len(res.Steps))
		for i, val := range res.Steps {
			vres.Steps[i] = transformStepToStepviewsStepView(val)
		}
	}
	return vres
}

// transformStepviewsStepViewToStep builds a value of type *Step from a value
// of type *stepviews.StepView.
func transformStepviewsStepViewToStep(v *stepviews.StepView) *Step {
	if v == nil {
		return nil
	}
	res := &Step{
		Targetid: *v.Targetid,
		Type:     *v.Type,
		Value:    *v.Value,
		Sequence: *v.Sequence,
		Action:   *v.Action,
	}

	return res
}

// transformStepToStepviewsStepView builds a value of type *stepviews.StepView
// from a value of type *Step.
func transformStepToStepviewsStepView(v *Step) *stepviews.StepView {
	res := &stepviews.StepView{
		Targetid: &v.Targetid,
		Type:     &v.Type,
		Value:    &v.Value,
		Sequence: &v.Sequence,
		Action:   &v.Action,
	}

	return res
}
