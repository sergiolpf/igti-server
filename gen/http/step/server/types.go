// Code generated by goa v3.1.1, DO NOT EDIT.
//
// step HTTP server types
//
// Command:
// $ goa gen guide.me/design

package server

import (
	goa "goa.design/goa/v3/pkg"
	step "guide.me/gen/step"
	stepviews "guide.me/gen/step/views"
)

// AddRequestBody is the type of the "step" service "add" endpoint HTTP request
// body.
type AddRequestBody struct {
	// The id of the Walkthrough those steps belong to.
	WtID *string `form:"wtId,omitempty" json:"wtId,omitempty" xml:"wtId,omitempty"`
	// List of steps for a given walkthrough.
	Steps []*StepRequestBody `form:"steps,omitempty" json:"steps,omitempty" xml:"steps,omitempty"`
}

// UpdateRequestBody is the type of the "step" service "update" endpoint HTTP
// request body.
type UpdateRequestBody struct {
	// ID is the unique id of the Step.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// The id of the Walkthrough those steps belong to.
	WtID *string `form:"wtId,omitempty" json:"wtId,omitempty" xml:"wtId,omitempty"`
	// List of steps for a given walkthrough.
	Steps []*StepRequestBody `form:"steps,omitempty" json:"steps,omitempty" xml:"steps,omitempty"`
}

// ListResponseBody is the type of the "step" service "list" endpoint HTTP
// response body.
type ListResponseBody struct {
	// ID is the unique id of the Step.
	ID string `form:"id" json:"id" xml:"id"`
	// The id of the Walkthrough those steps belong to.
	WtID string `form:"wtId" json:"wtId" xml:"wtId"`
	// List of steps for a given walkthrough.
	Steps []*StepResponseBody `form:"steps" json:"steps" xml:"steps"`
}

// StepResponseBody is used to define fields on response body types.
type StepResponseBody struct {
	// A string representing the HTML ID of an element
	Targetid string `form:"targetid" json:"targetid" xml:"targetid"`
	// The type of step to be used
	Type string `form:"type" json:"type" xml:"type"`
	// The content of the message to be displayed
	Value string `form:"value" json:"value" xml:"value"`
	// The number in the sequence that the step belongs to.
	Sequence int32 `form:"sequence" json:"sequence" xml:"sequence"`
	// What action should trigger the next step
	Action string `form:"action" json:"action" xml:"action"`
}

// StepRequestBody is used to define fields on request body types.
type StepRequestBody struct {
	// A string representing the HTML ID of an element
	Targetid *string `form:"targetid,omitempty" json:"targetid,omitempty" xml:"targetid,omitempty"`
	// The type of step to be used
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
	// The content of the message to be displayed
	Value *string `form:"value,omitempty" json:"value,omitempty" xml:"value,omitempty"`
	// The number in the sequence that the step belongs to.
	Sequence *int32 `form:"sequence,omitempty" json:"sequence,omitempty" xml:"sequence,omitempty"`
	// What action should trigger the next step
	Action *string `form:"action,omitempty" json:"action,omitempty" xml:"action,omitempty"`
}

// NewListResponseBody builds the HTTP response body from the result of the
// "list" endpoint of the "step" service.
func NewListResponseBody(res *stepviews.StoredStepsView) *ListResponseBody {
	body := &ListResponseBody{
		ID:   *res.ID,
		WtID: *res.WtID,
	}
	if res.Steps != nil {
		body.Steps = make([]*StepResponseBody, len(res.Steps))
		for i, val := range res.Steps {
			body.Steps[i] = marshalStepviewsStepViewToStepResponseBody(val)
		}
	}
	return body
}

// NewListPayload builds a step service list endpoint payload.
func NewListPayload(id string) *step.ListPayload {
	v := &step.ListPayload{}
	v.ID = id

	return v
}

// NewAddSteps builds a step service add endpoint payload.
func NewAddSteps(body *AddRequestBody) *step.Steps {
	v := &step.Steps{
		WtID: body.WtID,
	}
	if body.Steps != nil {
		v.Steps = make([]*step.Step, len(body.Steps))
		for i, val := range body.Steps {
			v.Steps[i] = unmarshalStepRequestBodyToStepStep(val)
		}
	}

	return v
}

// NewRemovePayload builds a step service remove endpoint payload.
func NewRemovePayload(id string) *step.RemovePayload {
	v := &step.RemovePayload{}
	v.ID = id

	return v
}

// NewUpdateStoredSteps builds a step service update endpoint payload.
func NewUpdateStoredSteps(body *UpdateRequestBody) *step.StoredSteps {
	v := &step.StoredSteps{
		ID:   *body.ID,
		WtID: *body.WtID,
	}
	v.Steps = make([]*step.Step, len(body.Steps))
	for i, val := range body.Steps {
		v.Steps[i] = unmarshalStepRequestBodyToStepStep(val)
	}

	return v
}

// ValidateAddRequestBody runs the validations defined on AddRequestBody
func ValidateAddRequestBody(body *AddRequestBody) (err error) {
	for _, e := range body.Steps {
		if e != nil {
			if err2 := ValidateStepRequestBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// ValidateUpdateRequestBody runs the validations defined on UpdateRequestBody
func ValidateUpdateRequestBody(body *UpdateRequestBody) (err error) {
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.WtID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("wtId", "body"))
	}
	if body.Steps == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("steps", "body"))
	}
	for _, e := range body.Steps {
		if e != nil {
			if err2 := ValidateStepRequestBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// ValidateStepRequestBody runs the validations defined on StepRequestBody
func ValidateStepRequestBody(body *StepRequestBody) (err error) {
	if body.Targetid == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("targetid", "body"))
	}
	if body.Type == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("type", "body"))
	}
	if body.Value == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("value", "body"))
	}
	if body.Sequence == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("sequence", "body"))
	}
	if body.Action == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("action", "body"))
	}
	if body.Type != nil {
		if !(*body.Type == "text" || *body.Type == "picture") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.type", *body.Type, []interface{}{"text", "picture"}))
		}
	}
	if body.Action != nil {
		if !(*body.Action == "click" || *body.Action == "next" || *body.Action == "end") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.action", *body.Action, []interface{}{"click", "next", "end"}))
		}
	}
	return
}
