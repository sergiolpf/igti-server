// Code generated by goa v3.1.1, DO NOT EDIT.
//
// step HTTP client types
//
// Command:
// $ goa gen guide.me/design

package client

import (
	goa "goa.design/goa/v3/pkg"
	step "guide.me/gen/step"
	stepviews "guide.me/gen/step/views"
)

// AddRequestBody is the type of the "step" service "add" endpoint HTTP request
// body.
type AddRequestBody struct {
	// The id of the Walkthrough those steps belong to.
	WtID *string `form:"wtId,omitempty" json:"wtId,omitempty" xml:"wtId,omitempty"`
	// List of steps for a given walkthrough.
	Steps []*StepRequestBody `form:"steps,omitempty" json:"steps,omitempty" xml:"steps,omitempty"`
}

// UpdateRequestBody is the type of the "step" service "update" endpoint HTTP
// request body.
type UpdateRequestBody struct {
	// ID is the unique id of the Step.
	ID string `form:"id" json:"id" xml:"id"`
	// The id of the Walkthrough those steps belong to.
	WtID string `form:"wtId" json:"wtId" xml:"wtId"`
	// List of steps for a given walkthrough.
	Steps []*StepRequestBody `form:"steps" json:"steps" xml:"steps"`
}

// ListResponseBody is the type of the "step" service "list" endpoint HTTP
// response body.
type ListResponseBody struct {
	// ID is the unique id of the Step.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// The id of the Walkthrough those steps belong to.
	WtID *string `form:"wtId,omitempty" json:"wtId,omitempty" xml:"wtId,omitempty"`
	// List of steps for a given walkthrough.
	Steps []*StepResponseBody `form:"steps,omitempty" json:"steps,omitempty" xml:"steps,omitempty"`
}

// StepResponseBody is used to define fields on response body types.
type StepResponseBody struct {
	// A string representing the HTML ID of an element
	Targetid *string `form:"targetid,omitempty" json:"targetid,omitempty" xml:"targetid,omitempty"`
	// The type of step to be used
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
	// The content of the message to be displayed
	Value *string `form:"value,omitempty" json:"value,omitempty" xml:"value,omitempty"`
	// The number in the sequence that the step belongs to.
	Sequence *int32 `form:"sequence,omitempty" json:"sequence,omitempty" xml:"sequence,omitempty"`
	// What action should trigger the next step
	Action *string `form:"action,omitempty" json:"action,omitempty" xml:"action,omitempty"`
}

// StepRequestBody is used to define fields on request body types.
type StepRequestBody struct {
	// A string representing the HTML ID of an element
	Targetid string `form:"targetid" json:"targetid" xml:"targetid"`
	// The type of step to be used
	Type string `form:"type" json:"type" xml:"type"`
	// The content of the message to be displayed
	Value string `form:"value" json:"value" xml:"value"`
	// The number in the sequence that the step belongs to.
	Sequence int32 `form:"sequence" json:"sequence" xml:"sequence"`
	// What action should trigger the next step
	Action string `form:"action" json:"action" xml:"action"`
}

// NewAddRequestBody builds the HTTP request body from the payload of the "add"
// endpoint of the "step" service.
func NewAddRequestBody(p *step.Steps) *AddRequestBody {
	body := &AddRequestBody{
		WtID: p.WtID,
	}
	if p.Steps != nil {
		body.Steps = make([]*StepRequestBody, len(p.Steps))
		for i, val := range p.Steps {
			body.Steps[i] = marshalStepStepToStepRequestBody(val)
		}
	}
	return body
}

// NewUpdateRequestBody builds the HTTP request body from the payload of the
// "update" endpoint of the "step" service.
func NewUpdateRequestBody(p *step.StoredSteps) *UpdateRequestBody {
	body := &UpdateRequestBody{
		ID:   p.ID,
		WtID: p.WtID,
	}
	if p.Steps != nil {
		body.Steps = make([]*StepRequestBody, len(p.Steps))
		for i, val := range p.Steps {
			body.Steps[i] = marshalStepStepToStepRequestBody(val)
		}
	}
	return body
}

// NewListStoredStepsOK builds a "step" service "list" endpoint result from a
// HTTP "OK" response.
func NewListStoredStepsOK(body *ListResponseBody) *stepviews.StoredStepsView {
	v := &stepviews.StoredStepsView{
		ID:   body.ID,
		WtID: body.WtID,
	}
	v.Steps = make([]*stepviews.StepView, len(body.Steps))
	for i, val := range body.Steps {
		v.Steps[i] = unmarshalStepResponseBodyToStepviewsStepView(val)
	}

	return v
}

// ValidateStepResponseBody runs the validations defined on StepResponseBody
func ValidateStepResponseBody(body *StepResponseBody) (err error) {
	if body.Targetid == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("targetid", "body"))
	}
	if body.Type == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("type", "body"))
	}
	if body.Value == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("value", "body"))
	}
	if body.Sequence == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("sequence", "body"))
	}
	if body.Action == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("action", "body"))
	}
	if body.Type != nil {
		if !(*body.Type == "text" || *body.Type == "picture") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.type", *body.Type, []interface{}{"text", "picture"}))
		}
	}
	if body.Action != nil {
		if !(*body.Action == "click" || *body.Action == "next" || *body.Action == "end") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.action", *body.Action, []interface{}{"click", "next", "end"}))
		}
	}
	return
}

// ValidateStepRequestBody runs the validations defined on StepRequestBody
func ValidateStepRequestBody(body *StepRequestBody) (err error) {
	if !(body.Type == "text" || body.Type == "picture") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.type", body.Type, []interface{}{"text", "picture"}))
	}
	if !(body.Action == "click" || body.Action == "next" || body.Action == "end") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.action", body.Action, []interface{}{"click", "next", "end"}))
	}
	return
}
